import psycopg2
import pandas as pd
import math as m
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
connection = psycopg2.connect(database="TEST",
                             user="puser",
                              password="pass",
                              host="localhost",
                              port='number_port')
cursor = connection.cursor()

con1 = connection.cursor()
con1.execute("""
    SELECT * FROM DADOS;
""")

query1 = con1.fetchall()
con1.close()
d1 = []
for i in query1:
    id = int(i[0])
    diametro = float(i[1])
    d1.append([id,diametro])

dados = pd.DataFrame(d1, columns=['ID', 'DIAMETRO'])
# quantidade de intervalos

I = m.ceil(m.log2(len(dados)) + 2)

min_value = dados['DIAMETRO'].min()
max_value = dados['DIAMETRO'].max()

class_amp = int(m.ceil((max_value - min_value) / I))
# O demônio de um histograma 
diametro_table_frequency = pd.DataFrame(columns=['Classes','Frequencia','frequencia relativa',
                                                'frequencia relatiav percentual', 'frequencia acumulada',
                                                'frequencia acumulada percentual'], index=range(class_amp))
print(len(diametro_table_frequency))
data_histogram = []
fa = 0
far = 0
total = dados['DIAMETRO'].count()
for i in range(class_amp):
    lower = min_value + i * I
    upper = min_value + (i + 1) * I
    freq = dados[(dados['DIAMETRO'] >= lower) & (dados['DIAMETRO'] < upper)].shape[0]
    freq_re = round(freq / total, 4)
    freq_re_p = round(freq_re * 100, 2)
    fa += freq
    far = round((fa/total)*100,2)
    diametro_table_frequency.loc[i] = [f'[{lower}, {upper})', freq, freq_re, freq_re_p, fa,far]
    

    data_histogram.extend([lower + (upper - lower) / 2] * freq)

#print(diametro_table_frequency)

sns.histplot(data_histogram, bins=len(diametro_table_frequency), color='lightgreen', edgecolor='red')
plt.xlabel('CLASSES')
plt.ylabel('Frequencia de observações')
plt.title('Histograma com diâmetro dos microfósseis coloniais')
for p in plt.gca().patches:
    height = p.get_height()
    plt.text(p.get_x() + p.get_width() / 2., height + 0.1,
             f'{int(height)}', ha="center", fontsize=10)
#plt.show()

dados_mediana = dados['DIAMETRO'].sort_values( ascending=True).reset_index(drop=True)
mediana = dados_mediana.median()
media = round(dados_mediana.mean(),4)

media_ceil = m.ceil(media)
media_floor = m.floor(media)
varianca = round(np.var(dados_mediana),4)
std = round(np.std(dados_mediana), 4)
coef_variacao = round( np.std(dados_mediana) / np.mean(dados_mediana)*100,4)
print(f"Mediana: {mediana}")
print(f"Média: {media}")
print(f"Média arredondada para cima: {media_ceil}")
print(f"Média arredondada para baixo: {media_floor}")
print(f"Variância: {varianca}")
print(f"Desvio Padrao: {std}")
print(f"Coefieciente de variacao: {coef_variacao}")


# Criando o gráfico de caixa
fig = plt.figure(figsize=(12, 6))
plt.boxplot(dados['DIAMETRO'], notch=True, sym='+')
plt.xticks([1], ['DIAMETRO'])
plt.ylim(dados['DIAMETRO'].min() - 1, dados['DIAMETRO'].max() + 1)
plt.grid(True, color='gray', linestyle='--', linewidth=0.7)
plt.show()

fig = plt.figure(figsize=(10, 7))
plt.boxplot(dados['DIAMETRO'])
#plt.show()
